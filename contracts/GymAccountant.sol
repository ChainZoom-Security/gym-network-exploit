// SPDX-License-Identifier: MIT

pragma solidity 0.8.12;

import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "./interfaces/IAccountant.sol";
import "./interfaces/IGymMLM.sol";

/**
 * @notice Accountant contract:
 *   Stores information about user tokens rewarded
 */
contract GymAccountant is IAccountant, OwnableUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    event BorrowedAmountUpdated(
        address indexed user,
        uint32 contractType,
        uint256 amount,
        uint256 newFinalAmountValue
    );

    // Related contract addresses
    address public farmingContractAddress;
    address public vaultContractAddress;
    address public gymMLMContractAddress;
    address public tokenAddress;

    function initialize() external initializer {
        __Ownable_init();
    }

    function setFarmingContractAddress(address _farmingContractAddress)
        external
        onlyOwner
    {
        farmingContractAddress = _farmingContractAddress;
    }

    function setVaultContractAddress(address _vaultContractAddress)
        external
        onlyOwner
    {
        vaultContractAddress = _vaultContractAddress;
    }

    function setgymMLMContractAddress(address _gymMLMContractAddress)
        external
        onlyOwner
    {
        gymMLMContractAddress = _gymMLMContractAddress;
    }

    function setTokenAddress(address _tokenAddress) external onlyOwner {
        tokenAddress = _tokenAddress;
    }

    // Modifiers

    modifier onlyRelatedContracts() {
        require(
            msg.sender == gymMLMContractAddress,
            "GymAccountant:: Only related accounts can call the method"
        );
        _;
    }

    // Contract data
    // Mapping for store VaultBank borrowed amount
    mapping(address => uint256) public borrowedAmount;

    // Mapping for store borrowed amount by type (2 - Farming, 3 - SinglePool)
    mapping(uint32 => mapping(address => uint256)) public borrowedAmountByType;

    /**
     * @notice Function to claim pending rewards
     * @param _type: type of pending rewards (
                1 - VaultBank,
                2 - Farming,
                3 - SinglePool
       )
     */
    function claimPendingRewards(uint32 _type) external {
        require(
            gymMLMContractAddress != address(0),
            "GymAccountant:: GYMMLM contract address is zero address"
        );

        uint256 _pendingRewards = IGymMLM(gymMLMContractAddress)
            .getPendingRewards(msg.sender, _type);

        require(_pendingRewards > 0, "GymAccountant:: Zero pending rewards");
        _claimPendingRewards(msg.sender, _pendingRewards, _type);
    }

    /**
     * @notice Function to update the amount of tokens users owe to the system
     * @param _userAddress Address of the user who owes the system some tokens
     * @param _increase Boolean flag for addition
     * @param _amount Amount of tokens user owes
     * @param _type: type of pending rewards (
                1 - VaultBank,
                2 - Farming,
                3 - SinglePool
       )
     */
    function updateBorrowedAmount(
        address _userAddress,
        uint256 _amount,
        bool _increase,
        uint32 _type
    ) public onlyRelatedContracts {
        _updateBorrowedAmount(_userAddress, _amount, _increase, _type);
    }

    /**
     * @notice Function returns the amount of tokens user owes to the system
     * @param _userAddress Address of the user
     */
    function getUserBorrowedAmount(address _userAddress, uint32 _type)
        public
        view
        onlyRelatedContracts
        returns (uint256 amount)
    {
        if (_type == 1) {
            return borrowedAmount[_userAddress];
        } else {
            return borrowedAmountByType[_type][_userAddress];
        }
    }

    /**
     * @notice Private function to claim pending rewards
     * @param _userAddress User address to claim pending rewards
     * @param _pendingRewards: Amaunt of rewards
     * @param _type: type of pending rewards (
                1 - VaultBank,
                2 - Farming,
                3 - SinglePool
       )
     */
    function _claimPendingRewards(
        address _userAddress,
        uint256 _pendingRewards,
        uint32 _type
    ) private {
        require(
            tokenAddress != address(0),
            "GymAccountant:: Token address is zero"
        );
        require(
            IERC20Upgradeable(tokenAddress).transfer(
                _userAddress,
                _pendingRewards
            ),
            "GymAccountant:: Transfer failed"
        );
        _updateBorrowedAmount(_userAddress, _pendingRewards, true, _type);
    }

    /**
     * @notice Private function to update the amount of tokens users owe to the system
     * @param _userAddress Address of the user who owes the system some tokens
     * @param _increase Boolean flag for addition
     * @param _amount Amount of tokens user owes
     * @param _type: type of pending rewards (
                1 - VaultBank,
                2 - Farming,
                3 - SinglePool
       )
     */
    function _updateBorrowedAmount(
        address _userAddress,
        uint256 _amount,
        bool _increase,
        uint32 _type
    ) private {
        if (_increase) {
            if (_type == 1) {
                borrowedAmount[_userAddress] += _amount;
            } else {
                borrowedAmountByType[_type][_userAddress] += _amount;
            }
        } else {
            if (_type == 1) {
                borrowedAmount[_userAddress] -= _amount;
            } else {
                borrowedAmountByType[_type][_userAddress] -= _amount;
            }
        }
        uint256 returnAmount = _type == 1
            ? borrowedAmount[_userAddress]
            : borrowedAmountByType[_type][_userAddress];
        emit BorrowedAmountUpdated(_userAddress, _type, _amount, returnAmount);
    }
}
