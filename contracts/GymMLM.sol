// SPDX-License-Identifier: MIT

pragma solidity 0.8.12;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/IAccountant.sol";
import "./interfaces/IGymSinglePool.sol";
import "./interfaces/IVault.sol";
import "./interfaces/IFarming.sol";
import "hardhat/console.sol";

contract GymMLM is OwnableUpgradeable {
    uint256 public currentId;
    uint256 public oldUserTransferTimestampLimit;

    address public bankAddress;

    uint256[16] public directReferralBonuses;
    uint256[16] public levels;
    uint256[16] public oldUserLevels;

    mapping(address => uint256) public addressToId;
    mapping(uint256 => address) public idToAddress;
    mapping(address => uint256) public investment;
    mapping(address => address) public userToReferrer;
    mapping(address => uint256) public scoring;
    mapping(address => uint256) public firstDepositTimestamp;

    address public farming;
    address public singlePool;
    uint256 public singlePoolStartTimestamp;
    event NewReferral(address indexed user, address indexed referral);

    event ReferralRewardReceived(
        address indexed user,
        address indexed referral,
        uint256 level,
        uint256 amount,
        address wantAddress
    );

    /**
     * @notice User qualification
     * @param ownDepositBNB: User deposit vault in BNB. *100
     * @param usdAmountPool: User active uds amount pool.
     * @param directPartners: User direct partners
     * @param partnerLevel: User partner level
     */
    struct UserQualification {
        uint256 depositBNB;
        uint256 usdAmountPool;
        uint32 directPartners;
        uint32 partnerLevel;
    }

    uint256 public directPartnersConditionsTimestamp;
    address public accountContractAddress;

    mapping(uint32 => UserQualification) public userQualification;
    mapping(address => address[]) public directPartners;

    function initialize() external initializer {
        directReferralBonuses = [
            1000,
            700,
            500,
            400,
            400,
            300,
            100,
            100,
            100,
            50,
            50,
            50,
            50,
            50,
            25,
            25
        ];
        addressToId[0x49A6DaD36768c23eeb75BD253aBBf26AB38BE4EB] = 1;
        idToAddress[1] = 0x49A6DaD36768c23eeb75BD253aBBf26AB38BE4EB;
        userToReferrer[
            0x49A6DaD36768c23eeb75BD253aBBf26AB38BE4EB
        ] = 0x49A6DaD36768c23eeb75BD253aBBf26AB38BE4EB;
        currentId = 2;
        levels = [
            0.05 ether,
            0.1 ether,
            0.25 ether,
            0.5 ether,
            1 ether,
            3 ether,
            5 ether,
            10 ether,
            15 ether,
            25 ether,
            30 ether,
            35 ether,
            40 ether,
            70 ether,
            100 ether,
            200 ether
        ];
        oldUserLevels = [
            0 ether,
            0.045 ether,
            0.045 ether,
            0.045 ether,
            0.045 ether,
            0.045 ether,
            1.35 ether,
            4.5 ether,
            9 ether,
            13.5 ether,
            22.5 ether,
            27 ether,
            31.5 ether,
            36 ether,
            45 ether,
            90 ether
        ];

        __Ownable_init();
    }

    modifier onlyBank() {
        require(
            msg.sender == bankAddress ||
                msg.sender == farming ||
                msg.sender == singlePool,
            "GymMLM:: Only bank"
        );
        _;
    }

    receive() external payable {}

    fallback() external payable {}

    /**
     * @notice  Function to set conditions timestamp
     * @param timestamp timestamp for set up
     */
    function setDirectPartnersConditionsTimestamp(uint256 timestamp)
        external
        onlyOwner
    {
        directPartnersConditionsTimestamp = timestamp;
    }

    /**
     * @notice  Function to set conditions timestamp
     * @param _level:  qualification level
     * @param _depositBNB:  value of min deposit in BNB
     * @param _gymnetFarm:  value of min gymnet farm
     * @param _directPartnersCount:  direct partners count
     * @param _partnerLevel:  direct partner level
     */
    function setUserQualification(
        uint32 _level,
        uint256 _depositBNB,
        uint256 _gymnetFarm,
        uint32 _directPartnersCount,
        uint32 _partnerLevel
    ) external onlyOwner {
        userQualification[_level] = UserQualification(
            _depositBNB,
            _gymnetFarm,
            _directPartnersCount,
            _partnerLevel
        );
    }

    /**
     * @notice  Function to update MLM commission
     * @param _level commission level for change
     * @param _commission new commission
     */
    function updateMLMCommission(uint256 _level, uint256 _commission)
        external
        onlyOwner
    {
        directReferralBonuses[_level] = _commission;
    }

    /**
     * @notice  Function to update direct partners information
     * @param _referrer: Address of referrer user
     * @param _directPartners: Array of addresses of user direct partners
     */
    function updateDirectPartners(
        address _referrer,
        address[] calldata _directPartners
    ) external {
        for (uint32 i = 0; i < _directPartners.length; i++) {
            if (
                userToReferrer[_directPartners[i]] == _referrer &&
                isUniqueDirectPartner(_referrer, _directPartners[i])
            ) {
                directPartners[_referrer].push(_directPartners[i]);
            }
        }
    }

    function updateScoring(address _token, uint256 _score) external onlyOwner {
        scoring[_token] = _score;
    }

    function _addUser(address _user, address _referrer) private {
        addressToId[_user] = currentId;
        idToAddress[currentId] = _user;
        userToReferrer[_user] = _referrer;
        directPartners[_referrer].push(_user);
        currentId++;
        emit NewReferral(_referrer, _user);
    }

    /**
     * @notice  Function to add GymMLM
     * @param _user Address of user
     * @param _referrerId Address of referrer
     */
    function addGymMLM(address _user, uint256 _referrerId) external onlyBank {
        address _referrer = userToReferrer[_user];

        if (_referrer == address(0)) {
            _referrer = idToAddress[_referrerId];
        }

        require(_user != address(0), "GymMLM::user is zero address");

        require(_referrer != address(0), "GymMLM::referrer is zero address");

        require(
            userToReferrer[_user] == address(0) ||
                userToReferrer[_user] == _referrer,
            "GymMLM::referrer is zero address"
        );

        // If user didn't exsist before
        if (addressToId[_user] == 0) {
            _addUser(_user, _referrer);
        }
    }

    /**
     * @notice Function to distribute rewards to referrers
     * @param _wantAmt Amount of assets that will be distributed
     * @param _wantAddr Address of want token contract
     * @param _user Address of user
     * @param _type: type of pending rewards (
                1 - VaultBank,
                2 - Farming,
                3 - SinglePool
       )
     */
    function distributeRewards(
        uint256 _wantAmt,
        address _wantAddr,
        address _user,
        uint32 _type
    ) public onlyBank {
        uint256 index;
        uint256 length = directReferralBonuses.length;

        IERC20 token = IERC20(_wantAddr);

        while (index < length && addressToId[userToReferrer[_user]] != 1) {
            address referrer = userToReferrer[_user];
            if (index <= _getUserLevel(referrer) && investment[referrer] > 0) {
                uint256 reward = (_wantAmt * directReferralBonuses[index]) /
                    10000;
                uint256 rewardToTransfer = reward;
                // update accountant information
                uint256 _borrowedAmount = IAccountant(accountContractAddress)
                    .getUserBorrowedAmount(referrer, _type);
                if (
                    _borrowedAmount > 0 &&
                    _wantAddr == 0x3a0d9d7764FAE860A659eb96A500F1323b411e68
                ) {
                    if (reward >= _borrowedAmount) {
                        token.transfer(accountContractAddress, _borrowedAmount);
                        IAccountant(accountContractAddress)
                            .updateBorrowedAmount(
                                referrer,
                                _borrowedAmount,
                                false,
                                _type
                            );
                        rewardToTransfer = reward - _borrowedAmount;
                    } else {
                        token.transfer(accountContractAddress, reward);
                        IAccountant(accountContractAddress)
                            .updateBorrowedAmount(
                                referrer,
                                reward,
                                false,
                                _type
                            );
                        rewardToTransfer = 0;
                    }
                }
                // ====
                require(
                    token.transfer(referrer, rewardToTransfer),
                    "GymMLM:: Transfer failed"
                );
                emit ReferralRewardReceived(
                    referrer,
                    _user,
                    index,
                    reward,
                    _wantAddr
                );
            }
            _user = userToReferrer[_user];
            index++;
        }

        if (token.balanceOf(address(this)) > 0) {
            require(
                token.transfer(
                    0x49A6DaD36768c23eeb75BD253aBBf26AB38BE4EB,
                    token.balanceOf(address(this))
                ),
                "GymMLM:: Transfer failed"
            );
        }

        return;
    }

    function setBankAddress(address _bank) external onlyOwner {
        bankAddress = _bank;
    }

    function setSinglePoolStartTimestamp(uint256 _singlePoolStartTimestamp)
        external
        onlyOwner
    {
        singlePoolStartTimestamp = _singlePoolStartTimestamp;
    }

    function setSinglePoolAddress(address _singlePool) external onlyOwner {
        singlePool = _singlePool;
    }

    function setOldUserTransferTimestampLimit(uint256 _limit)
        external
        onlyOwner
    {
        oldUserTransferTimestampLimit = _limit;
    }

    /**
     * @notice  Function to set Farming address
     * @param _address Address of treasury address
     */
    function setFarmingAddress(address _address) external onlyOwner {
        farming = _address;
    }

    function setAccountantAddress(address _address) external onlyOwner {
        accountContractAddress = _address;
    }

    function seedUsers(address[] memory _users, address[] memory _referrers)
        external
        onlyOwner
    {
        require(_users.length == _referrers.length, "Length mismatch");
        for (uint256 i; i < _users.length; i++) {
            addressToId[_users[i]] = currentId;
            idToAddress[currentId] = _users[i];
            userToReferrer[_users[i]] = _referrers[i];
            currentId++;

            emit NewReferral(_referrers[i], _users[i]);
        }
    }

    function updateInvestment(address _user, uint256 _newInvestment)
        external
        onlyBank
    {
        if (firstDepositTimestamp[_user] == 0)
            firstDepositTimestamp[_user] = block.timestamp;
        investment[_user] = _newInvestment;
    }

    /**
     * @notice Function to get pending rewards to referrers
     * @param _userAddress: User address
     * @param _type: type of pending rewards (
                1 - VaultBank,
                2 - Farming,
                3 - SinglePool
       )
     * @return Pending Rewards
     */
    function getPendingRewards(address _userAddress, uint32 _type)
        public
        view
        returns (uint256)
    {
        require(
            accountContractAddress != address(0),
            "GymMLM:: Account contract address is zero address"
        );

        uint32 _level = _getUserLevel(_userAddress);
        uint256 _rewardsPendingTotal = _getPendingRewards(
            _userAddress,
            _type,
            _level,
            0
        );
        uint256 _borrowedAmount = IAccountant(accountContractAddress)
            .getUserBorrowedAmount(_userAddress, _type);

        if (_borrowedAmount >= _rewardsPendingTotal) {
            return 0;
        }

        return _rewardsPendingTotal - _borrowedAmount;
    }

    /**
     * @notice Public function to define default userQualification
     */
    function setDefaultQualificationData() public onlyOwner {
        userQualification[0] = UserQualification(0.05 ether, 0, 0, 0);
        userQualification[1] = UserQualification(0.1 ether, 0, 0, 0);
        userQualification[2] = UserQualification(0.25 ether, 200, 0, 0);
        userQualification[3] = UserQualification(0.5 ether, 200, 0, 0);
        userQualification[4] = UserQualification(1 ether, 2000, 2, 2);
        userQualification[5] = UserQualification(3 ether, 4000, 3, 2);
        userQualification[6] = UserQualification(5 ether, 10000, 5, 2);
        userQualification[7] = UserQualification(10 ether, 20000, 5, 2);
        userQualification[8] = UserQualification(15 ether, 40000, 6, 5);
        userQualification[9] = UserQualification(25 ether, 45000, 7, 5);
        userQualification[10] = UserQualification(30 ether, 50000, 8, 5);
        userQualification[11] = UserQualification(35 ether, 60000, 9, 5);
        userQualification[12] = UserQualification(40 ether, 65000, 10, 5);
        userQualification[13] = UserQualification(70 ether, 70000, 5, 5);
        userQualification[14] = UserQualification(100 ether, 75000, 5, 5);
        userQualification[15] = UserQualification(200 ether, 80000, 5, 5);
    }

    /**
     * @notice Public function to get GYMNET amount
     * @param _userAddress: User address for get active gymnet amount
     */
    function getUSDAmount(address _userAddress) public view returns (uint256) {
        require(singlePool != address(0), "GymMLM::Single pool address zero");
        return
            IGymSinglePool(singlePool)
                .getUserInfo(_userAddress)
                .totalDepositDollarValue;
    }

    /**
     * @notice Public view function to user qualification
     * @param _userAddress: user address to get the qualification
     * @return _userQualification User Qualification
     */
    function getUserDirectPartnerQualification(address _userAddress)
        public
        view
        returns (uint32 _userQualification)
    {
        address[] memory _directPartners = directPartners[_userAddress];
        uint256 _usdAmount = getUSDAmount(_userAddress);
        for (uint32 i = 0; i < levels.length; i++) {
            if (
                investment[_userAddress] >= userQualification[i].depositBNB &&
                _usdAmount >= userQualification[i].usdAmountPool &&
                _directPartners.length >= userQualification[i].directPartners &&
                checkPartnersLevel(
                    _directPartners,
                    userQualification[i].partnerLevel
                )
            ) {
                _userQualification = i;
            } else {
                break;
            }
        }
    }

    /**
     * @notice Public view function to get user MLM level
     * @param _user: user address to get the level
     * @return userLevel user MLM level
     */
    function getUserCurrentLevel(address _user)
        public
        view
        returns (uint32 userLevel)
    {
        return _getUserLevel(_user);
    }

    /**
     * @notice Internal view function to check direct partners levels
     * @param _partners: array of addresses for check
     * @param _level: minimum level of partner
     * @return bool flag
     */
    function checkPartnersLevel(address[] memory _partners, uint32 _level)
        internal
        view
        returns (bool)
    {
        if (_level == 0) return true;
        for (uint32 i = 0; i < _partners.length; i++) {
            if (_getUserLevel(_partners[i]) < _level - 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * @notice Internal view function to get user MLM level
     * @param _userAddress: user address to get the level
     * @return user MLM level
     */
    function _getUserLevel(address _userAddress)
        internal
        view
        returns (uint32)
    {
        uint32 _userLevel;
        uint256 _firstDepositTimestamp = firstDepositTimestamp[_userAddress];
        address[] memory _directPartners = directPartners[_userAddress];
        uint256 _usdAmount = getUSDAmount(_userAddress);
        for (uint32 i = 0; i < levels.length; i++) {
            if (
                (_firstDepositTimestamp < oldUserTransferTimestampLimit &&
                    investment[_userAddress] >= oldUserLevels[i]) ||
                (oldUserTransferTimestampLimit < _firstDepositTimestamp &&
                    (directPartnersConditionsTimestamp == 0 ||
                        _firstDepositTimestamp <
                        directPartnersConditionsTimestamp) &&
                    investment[_userAddress] >= levels[i])
            ) {
                _userLevel = i;
            } else if (
                directPartnersConditionsTimestamp != 0 &&
                directPartnersConditionsTimestamp < _firstDepositTimestamp
            ) {
                if (
                    investment[_userAddress] >=
                    userQualification[i].depositBNB &&
                    _usdAmount >= userQualification[i].usdAmountPool &&
                    _directPartners.length >=
                    userQualification[i].directPartners &&
                    checkPartnersLevel(
                        _directPartners,
                        userQualification[i].partnerLevel
                    )
                ) {
                    _userLevel = i;
                } else {
                    break;
                }
            }
        }
        if (
            singlePoolStartTimestamp != 0 &&
            singlePoolStartTimestamp < block.timestamp
        ) {
            uint32 levelInSinglePool = IGymSinglePool(singlePool)
                .getUserLevelInSinglePool(_userAddress);
            // if(levelInSinglePool == 0) levelInSinglePool = 1;
            uint32 levelVaultAndPool = _userLevel >= levelInSinglePool
                ? levelInSinglePool
                : _userLevel;
            _userLevel = levelVaultAndPool;
        }

        return _userLevel;
    }

    /**
     * @notice Pure Function to calculate percent of amount
     * @param _amount: Amount
     * @param _percent: User address
     */
    function calculatePercentOfAmount(uint256 _amount, uint256 _percent)
        private
        pure
        returns (uint256)
    {
        return (_amount * _percent) / 10000;
    }

    /**
     * @notice Private function to get pending rewards to referrers
     * @param _userAddress: User address
     * @param _type: type of pending rewards (
                1 - VaultBank,
                2 - Farming,
                3 - SinglePool
       )
     * @param _level: User level (default = 0)
     * @param _depth: depth of direct partners (default = 0)
     * @return Pending Rewards
     */
    function _getPendingRewards(
        address _userAddress,
        uint32 _type,
        uint32 _level,
        uint32 _depth
    ) private view returns (uint256) {
        if (_depth > _level + 1) {
            return 0;
        }
        uint256 _rewardsPendingTotal;
        uint256 convertBalance;
        address[] memory _directChilds = directPartners[_userAddress];

        if (_depth != 0) {
            convertBalance = _getPendingRewardBalance(_userAddress, _type);
            _rewardsPendingTotal = calculatePercentOfAmount(
                convertBalance,
                directReferralBonuses[_depth - 1]
            );
        } else {
            _rewardsPendingTotal = 0;
        }

        for (uint32 i = 0; i < _directChilds.length; i++) {
            _rewardsPendingTotal += _getPendingRewards(
                _directChilds[i],
                _type,
                _level,
                _depth + 1
            );
        }

        return _rewardsPendingTotal;
    }

    /**
     * @notice Private function to get pending rewards to referrers
     * @param _userAddress: User address
     * @param _type: type of pending rewards (
                1 - VaultBank,
                2 - Farming,
                3 - SinglePool
       )
     * @return Pending Rewards
     */
    function _getPendingRewardBalance(address _userAddress, uint32 _type)
        private
        view
        returns (uint256)
    {
        uint256 convertBalance;
        if (_type == 1) {
            require(
                bankAddress != address(0),
                "GymMLM:: Vault contract address is zero address"
            );
            convertBalance = IVault(bankAddress).pendingReward(0, _userAddress);
        } else if (_type == 2) {
            require(
                farming != address(0),
                "GymMLM:: Farming contract address is zero address"
            );
            convertBalance = IFarming(farming).pendingRewardTotal(_userAddress);
        } else if (_type == 3) {
            require(
                singlePool != address(0),
                "GymMLM:: Single Pool contract address is zero address"
            );
            uint256 _depositId = IGymSinglePool(singlePool)
                .getUserInfo(_userAddress)
                .depositId;
            for (uint32 i = 0; i < _depositId; i++) {
                convertBalance += IGymSinglePool(singlePool).pendingReward(
                    i,
                    _userAddress
                );
            }
        }
        return convertBalance;
    }

    /**
     * @notice  Function to check is unique direct partner
     * @param _userAddress: Address of referrer user
     * @param _referrAddress: referr user address
     */
    function isUniqueDirectPartner(address _userAddress, address _referrAddress)
        private
        view
        returns (bool)
    {
        address[] memory _directPartners = directPartners[_userAddress];
        if (_directPartners.length == 0) {
            return true;
        }
        for (uint32 i = 0; i < _directPartners.length; i++) {
            if (_referrAddress == _directPartners[i]) {
                return false;
            }
        }
        return true;
    }
}
